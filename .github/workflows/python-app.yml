name: Python App CI/CD Pipeline

on:
  push:
    branches: [main]
  pull_request:
    branches: [main]
  workflow_dispatch:
    inputs:
      environment:
        description: "Environment to deploy to"
        required: true
        default: "production"
        type: choice
        options:
          - production
          - staging
          - development

env:
  PYTHON_VERSION: "3.13"
  APP_NAME: "python-app"

jobs:
  build:
    runs-on: ubuntu-latest

    steps:
      - uses: actions/checkout@v4

      - name: Set up Python
        uses: actions/setup-python@v4
        with:
          python-version: ${{ env.PYTHON_VERSION }}

      - name: Create application package
        run: |
          mkdir -p dist
          tar -czf dist/${{ env.APP_NAME }}-${{ github.sha }}.tar.gz \
            --exclude='.git' \
            --exclude='__pycache__' \
            --exclude='*.pyc' \
            --exclude='.pytest_cache' \
            --exclude='tests' \
            --exclude='.github' \
            .

      - name: Upload build artifacts
        uses: actions/upload-artifact@v4
        with:
          name: ${{ env.APP_NAME }}-${{ github.sha }}
          path: dist/
          retention-days: 30

  deploy:
    needs: build
    runs-on: ubuntu-latest

    steps:
      - name: Download build artifacts
        uses: actions/download-artifact@v4
        with:
          name: ${{ env.APP_NAME }}-${{ github.sha }}
          path: dist

      - name: Setup SSH key
        run: |
          mkdir -p ~/.ssh
          echo "${{ secrets.VM_SSH_PRIVATE_KEY }}" > ~/.ssh/id_rsa
          chmod 600 ~/.ssh/id_rsa
          ssh-keyscan -H ${{ secrets.VM_HOST }} >> ~/.ssh/known_hosts

      - name: Deploy to VM
        run: |
          # Upload the application package
          scp -i ~/.ssh/id_rsa dist/${{ env.APP_NAME }}-${{ github.sha }}.tar.gz \
            ${{ secrets.VM_USER }}@${{ secrets.VM_HOST }}:/tmp/

          # Execute deployment script on VM
          ssh -i ~/.ssh/id_rsa ${{ secrets.VM_USER }}@${{ secrets.VM_HOST }} << 'EOF'
            # Set variables
            APP_NAME="${{ env.APP_NAME }}"
            BUILD_ID="${{ github.sha }}"
            APP_DIR="/opt/${APP_NAME}"
            SERVICE_NAME="${APP_NAME}"
            
            # Create application directory
            sudo mkdir -p ${APP_DIR}
            
            # Stop the service if running
            sudo systemctl stop ${SERVICE_NAME} || true
            
            # Backup current version
            if [ -d "${APP_DIR}/current" ]; then
              sudo mv ${APP_DIR}/current ${APP_DIR}/backup-$(date +%Y%m%d-%H%M%S)
            fi

            # Save log and db files
            sudo mkdir - ${APP_DIR}/persistent
            cd ${APP_DIR}
            sudo mv application.log ${APP_DIR}/persistent/
            sudo mv database.db ${APP_DIR}/persistent/
            
            # Extract new version
            cd ${APP_DIR}
            sudo tar -xzf /tmp/${APP_NAME}-${BUILD_ID}.tar.gz -C ${APP_DIR}/
            sudo mv ${APP_NAME}-${BUILD_ID} current || sudo mv * current/

            # Set log and db files back
            sudo mv ${APP_DIR}/persistent/application.log ${APP_DIR}
            sudo mv ${APP_DIR}/persistent/database.db ${APP_DIR}

            # Set env file
            echo TGBOT_KEY=${{ secrets.TGBOT_KEY}} > .env.local
            
            # Set permissions
            sudo chown -R ${{ secrets.VM_SERVICE_USER }}:${{ secrets.VM_SERVICE_USER }} ${APP_DIR}
            
            # Install/update dependencies
            cd ${APP_DIR}
            source venv/bin/activate
            pip install -r requirements.txt

            # Start the service
            sudo systemctl start ${SERVICE_NAME}
            sudo systemctl enable ${SERVICE_NAME}
            
            # Verify deployment
            sleep 5
            if sudo systemctl is-active --quiet ${SERVICE_NAME}; then
              echo "Deployment successful - service is running"
            else
              echo "Deployment failed - service is not running"
              sudo systemctl status ${SERVICE_NAME}
              exit 1
            fi
            
            # Cleanup
            rm -f /tmp/${APP_NAME}-${BUILD_ID}.tar.gz
          EOF

      - name: Cleanup SSH
        if: always()
        run: |
          rm -f ~/.ssh/id_rsa
